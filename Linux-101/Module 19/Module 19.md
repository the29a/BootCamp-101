# 19. Дескрипторы файлов и перенаправления
Дескрипторы файлов
---
Файловый дескриптор (FD) в операционных системах Unix/Linux является индикатором соединения, поддерживаемого ядром для выполнения операций ввода/вывода (I/O). В операционных системах на базе Windows это называется дескриптором файла. Это соединение (обычно с файлом) от операционной системы для выполнения операций ввода-вывода (ввод/вывод байтов).

По умолчанию первые три файловых дескриптора в Linux:

     Поток данных для ввода
         STDIN - 0
     Поток данных для вывода
         STDOUT - 1
     Поток данных для вывода, связанный с возникшей ошибкой.
         STDERR - 2
         
STDIN и STDOUT
Давайте посмотрим на пример с cat. При запуске cat мы передаем запущенной программе наш стандартный ввод (STDIN - FD 0), отмеченный зеленым, в данном случае это "НЕКОТОРЫЙ ВВОД". Как только мы подтвердили наш ввод нажатием [ENTER], он возвращается в терминал как стандартный вывод (STDOUT - FD 1), отмеченный красным.

STDOUT и STDERR
В следующем примере, используя команду find, мы увидим стандартный вывод (STDOUT - FD 1), отмеченный зеленым, и стандартную ошибку (STDERR - FD 2), отмеченный красным.
```
the29a@host[~]$ find /etc/ -name shadow
```
В этом случае ошибка помечается и отображается как «Permissions denied». Мы можем проверить это, перенаправив файловый дескриптор ошибок (FD 2 - STDERR) в /dev/null. Таким образом, мы перенаправляем возникшие ошибки на «нулевое устройство», которое отбрасывает все данные.
```
the29a@host[~]$ find /etc/ -name shadow 2>/dev/null
```
Перенаправление STDOUT в файл
Теперь мы видим, что все ошибки (STDERR), ранее представленные как «Permission denied», больше не отображаются. Единственный результат, который мы видим сейчас, - это стандартный вывод (STDOUT), который мы также можем перенаправить в файл с именем «results.txt», который будет содержать только стандартный вывод без стандартных ошибок.
```
the29a@host[~]$ find /etc/ -name shadow 2>/dev/null > results.txt
```
Перенаправление STDOUT и STDERR в отдельные файлы
Мы должны были заметить, что в последнем примере мы не использовали число перед знаком «больше» (>). Это потому, что мы ранее перенаправляли все стандартные ошибки на «нулевое устройство», и единственный вывод, который мы получаем, - это стандартный вывод (FD 1 - STDOUT). Чтобы сделать это более точным, мы перенаправим стандартную ошибку (FD 2 - STDERR) и стандартный вывод (FD 1 - STDOUT) в разные файлы.
```
the29a@host[~]$ find /etc/ -name shadow 2> stderr.txt 1> stdout.txt
```
Перенаправление STDIN
Как мы уже видели, в сочетании с файловыми дескрипторами мы можем перенаправлять ошибки и вывод с помощью символа «больше» (>). Это также работает со знаком «меньше» (<). Однако знак «ниже» служит стандартным вводом (FD 0 - STDIN). Эти символы можно рассматривать как «направление» в виде стрелки, которая сообщает нам, «откуда» и «куда» данные должны быть перенаправлены. Мы используем команду cat, чтобы использовать содержимое файла "stdout.txt" как STDIN.
```
the29a@host[~]$ cat < stdout.txt
```
Перенаправление STDOUT и добавление в файл

Когда мы используем знак «больше» (>) для перенаправления нашего STDOUT, автоматически создается новый файл, если он еще не существует. Если этот файл существует, он будет перезаписан без запроса подтверждения. Если мы хотим добавить STDOUT к нашему существующему файлу, мы можем использовать двойной знак «больше» (>>).
```
the29a@host[~]$ find /etc/ -name passwd >> stdout.txt 2>/dev/null
```
Перенаправление STDIN потока в файл
Мы также можем использовать двойные нижние символы (<<), чтобы добавить наш стандартный ввод через поток. Мы можем использовать так называемую функцию конца файла (EOF) системного файла Linux, которая определяет конец ввода. В следующем примере мы будем использовать команду cat для чтения нашего потокового ввода через поток и направления его в файл с именем «stream.txt».
```
the29a@host[~]$ cat << EOF > stream.txt
```
Пайпы (Pipes)
Другой способ перенаправить STDOUT - использовать каналы (|). Это полезно, когда мы хотим использовать STDOUT из одной программы для обработки другой. Одним из наиболее часто используемых инструментов является grep, который мы будем использовать в следующем примере. Grep используется для фильтрации STDOUT в соответствии с определенным нами шаблоном. В следующем примере мы используем команду find для поиска всех файлов в каталоге /etc/ с расширением «.conf». Любые ошибки перенаправляются на «нулевое устройство» (/dev/null). Используя grep, мы отфильтровываем результаты и указываем, что должны отображаться только строки, содержащие шаблон «systemd».
```
the29a@host[~]$ find /etc/ -name *.conf 2>/dev/null | grep systemd
```
Перенаправления работают не только один раз. Мы можем использовать полученные результаты, чтобы перенаправить их в другую программу. В следующем примере мы будем использовать инструмент под названием wc, который должен подсчитывать общее количество полученных результатов.
```
the29a@host[~]$ find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l
```
Фильтрация содержимого
----
В последнем разделе мы узнали о перенаправлениях, которые мы можем использовать для перенаправления результатов из одной программы в другую для обработки. Для чтения файлов нам не обязательно использовать редактор. Есть два идентичных инструмента, которые называются более и менее. Это основные пейджеры, которые позволяют нам прокручивать файл в интерактивном режиме. Давайте посмотрим на несколько примеров.

* more
```
the29a@host[~]$ more /etc/passwd
```
После того, как мы прочитаем контент с помощью cat и перенаправим его на другие страницы, откроется уже упомянутый пейджер, и мы автоматически начнем с начала файла.
```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
<SNIP>
--More--
```
С помощью клавиши [Q] мы можем покинуть этот пейджер. Мы заметим, что вывод остается в терминале.

* less

Если теперь мы посмотрим на less, то заметим на странице руководства, что он содержит гораздо больше функций, чем more.

Отображает файл почти так же, как и more.
```
the29a@host[~]$ less /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
<SNIP>
```

Закрыв less с помощью клавиши [Q], мы заметим, что результат, который мы видели, в отличие от more, не остается в терминале.

* head

Иногда нас будут интересовать только конкретные вопросы в начале или в конце файла. Если мы хотим получить только первые строки файла, мы можем использовать заголовок инструмента. По умолчанию head печатает первые десять строк данного файла или ввода, если не указано иное.
```
the29a@host[~]$ head /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
```
* tail

Если мы хотим видеть только последние части файла или результаты, мы можем использовать аналог head, называемый tail, который возвращает последние десять строк.
```
the29a@host[~]$ tail /etc/passwd

miredo:x:115:65534::/var/run/miredo:/usr/sbin/nologin
usbmux:x:116:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:117:119:RealtimeKit,,,:/proc:/usr/sbin/nologin
nm-openvpn:x:118:120:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
nm-openconnect:x:119:121:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologin
pulse:x:120:122:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin
beef-xss:x:121:124::/var/lib/beef-xss:/usr/sbin/nologin
lightdm:x:122:125:Light Display Manager:/var/lib/lightdm:/bin/false
do-agent:x:998:998::/home/do-agent:/bin/false
user6:x:1000:1000:,,,:/home/user6:/bin/bash
```

* sort

В зависимости от того, какие результаты и файлы обрабатываются, они редко сортируются. Часто необходимо отсортировать желаемые результаты по алфавиту или по цифрам, чтобы получить лучший обзор. Для этого мы можем использовать инструмент под названием sort.
```
the29a@host[~]$ cat /etc/passwd | sort

_apt:x:104:65534::/nonexistent:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
the29a:x:1001:1001::/home/the29a:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
dnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
dovecot:x:114:117:Dovecot mail server,,,:/usr/lib/dovecot:/usr/sbin/nologin
dovenull:x:115:118:Dovecot login user,,,:/nonexistent:/usr/sbin/nologin
ftp:x:113:65534::/srv/ftp:/usr/sbin/nologin
games:x:5:60:games:/usr/games:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
<SNIP>
```

Как мы теперь видим, вывод больше не начинается с корня, а теперь отсортирован по алфавиту.

* grep

Чаще всего мы будем искать только определенные результаты, содержащие определенные нами шаблоны. Одним из наиболее часто используемых инструментов для этого является grep, который предлагает множество различных функций. Соответственно, мы можем искать пользователей, у которых в качестве примера установлена оболочка по умолчанию /bin/bash.
```
the29a@host[~]$ cat /etc/passwd | grep "/bin/bash"

root:x:0:0:root:/root:/bin/bash
the29a:x:1001:1001::/home/crythe29a:/bin/bash
```

Другая возможность - исключить конкретные результаты. Для этого с командой grep используется опция "-v". В следующем примере мы исключаем всех пользователей, которые отключили стандартную оболочку с именем /bin/false или /usr/bin/nologin.
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin"

root:x:0:0:root:/root:/bin/bash
sync:x:4:65534:sync:/bin:/bin/sync
postgres:x:111:117:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
user6:x:1000:1000:,,,:/home/user6:/bin/bash
```

* cut

Конкретные результаты с разными символами могут быть разделены разделителями. Здесь удобно знать, как удалить определенные разделители и показать слова в строке в указанной позиции. Один из инструментов, который можно для этого использовать - это cut. Поэтому мы используем опцию «-d» и устанавливаем в качестве разделителя символ двоеточия (:) и определяем опцией «-f» позицию в строке, которую мы хотим вывести.
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | cut -d":" -f1

root
sync
the29a
```

* tr
Еще одна возможность заменить определенные символы из строки на определенные нами символы - это инструмент tr. В качестве первого варианта мы определяем, какой символ мы хотим заменить, а в качестве второго варианта мы определяем символ, которым хотим его заменить. В следующем примере мы заменяем символ двоеточия пробелом.
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | tr ":" " "

root x 0 0 root /root /bin/bash
sync x 4 65534 sync /bin /bin/sync
```

* column
Поскольку такие результаты часто могут иметь нечеткое представление, утилита column  хорошо подходит для отображения таких результатов в табличной форме с использованием «-t».
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | tr ":" " " | column -t

root         x  0     0      root               /root        /bin/bash
sync         x  4     65534  sync               /bin         /bin/sync
the29a       x  1001  1001   /home/the29a     /bin/bash
```

* Awk

Как мы могли заметить, у пользователя postgres на одну строку слишком много. Чтобы упростить сортировку таких результатов, полезно использовать (g) awk, которое позволяет нам отображать первый ($1) и последний ($NF) результат строки.
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | tr ":" " " | awk '{print $1, $NF}'

root /bin/bash
sync /bin/sync
arpwatch /bin/sh
postgres /bin/bash
the29a /bin/bash
```

* sed

Наступят моменты, когда мы захотим изменить определенные имена во всем файле или на стандартном вводе. Один из инструментов, который мы можем использовать для этого, - редактор потока под названием sed. Одно из наиболее распространенных применений этого метода - замена текста. Здесь sed ищет шаблоны, которые мы определили в форме регулярных выражений (regex), и заменяет их другим шаблоном, который мы также определили. Давайте придерживаться последних результатов и скажем, что мы хотим заменить слово «bin» на «notbeen».

Флаг «s» в начале означает заменяющую команду. Затем мы указываем шаблон, который хотим заменить. После косой черты (/) мы вводим шаблон, который хотим использовать в качестве замены в третьей позиции. Наконец, мы используем флаг «g», который означает замену всех совпадений.

```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | tr ":" " " | awk '{print $1, $NF}' | sed 's/bin/notbin/g'

root /notbeen/bash
sync /notbeen/sync
arpwatch /notbeen/sh
postgres /notbeen/bash
the29a /notbeen/bash
```

* wc

И последнее, но не менее важное: часто бывает полезно узнать, сколько у нас успешных совпадений. Чтобы не подсчитывать строки или символы вручную, мы можем использовать инструмент wc. Опцией "-l" мы указываем, что учитываются только строки.
```
the29a@host[~]$ cat /etc/passwd | grep -v "false\|nologin" | tr ":" " " | awk '{print $1, $NF}' | wc -l
```
Практика

Поначалу может быть немного сложно иметь дело с таким количеством различных инструментов и их функций, если мы с ними не знакомы. Не торопитесь и экспериментируйте с инструментами. Взгляните на справочные страницы (man <tool>) или вызовите справку (<tool> -h / <tool> --help). Лучший способ познакомиться со всеми инструментами - это попрактиковаться. Старайтесь использовать их как можно чаще, и мы сможем интуитивно отфильтровать многие вещи через короткое время.
